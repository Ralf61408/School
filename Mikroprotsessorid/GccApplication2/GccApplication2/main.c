/*
 * GccApplication2.c
 *
 * Created: 26.08.2021 10:54:30
 * Author : ralfs
 */ 

// ?????????, ?????? ?? ??????????. ???????? ????????? waitForPress () «??????????» ? ????? WHILE, ??????, ???? ???????????? ?????? ????????.
// ????? ???????????? ??????? ???????? ????????, ??????? ?????????? 1 ??? 0.
// ? ???????? ????????? ??? ???????????? ???????? ?????????????? ? ???????????? ? IF-??????????? ?????? ????? FOR.
// ?????? ????? ????? ????? ?????????? waitForPress () (? ?????? ????????????? ????? ????? ?????; ? ?????? ??????????? ????? ????? ????????)
// ????????? ?????? ??? ??? ??????, WaitForPress () ?????????? ????????????. ?????? ????????? ??????, ??? ? ????? ?????? ??? ?? ????, ????, ?? ??????.

#define F_CPU 2000000UL
#include <avr/io.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

// Global
uint8_t Game[8];
int i;

uint16_t n = 500;



void ADC_Init() {
	 // It is not necessary that the ADC uses 10 Bit so should configure
    // left adjustment (ADLAR = 1)
	ADMUX = (1<<MUX1 | 1<<REFS0 | 1<<ADLAR);
	// ADEN --> ADC Enable | ADSC --> ADC Start Conversion | ADPS --> ADC Prescaler Select Bits (16)
	ADCSRA = (1<<ADEN)|(1<<ADSC)|(1<<ADPS2);	
}


unsigned int NewDelayValue() {
	// https://librambutan.readthedocs.io/en/latest/lang/cpp/bitshift.html
	// https://dfe.petrsu.ru/koi/posob/avrlab/mega16adc.html
	
    // Wait until it is ready to do ADC conversions. 
    while (ADCSRA & (1<<ADSC));

    // Read the ADC value:
	// When the ADC has completed a conversion operation, the result is stored in a pair of 8-bit registers 
	// (the 10-bit result won’t fit in a single 8-bit register).
	
	// if the result is left adjusted and no more than 8-bit precision is required, it is
    // sufficient to read ADCH. Otherwise, ADCL must be read first, then ADCH.
    unsigned char data = ADCH;

    // Create a number 1 - 8
    // 0   - 31  = 0 + 1 = 1 * 100 = 100
    // 32  - 63  = 1 + 1 = 2 * 100 = 200
    // ...
    // 224 - 255 = 7 + 1 = 8 * 100 = 800
	
	//return 100 * data;
	//return 100 * ((data<<5) + 1);
    return 100 * ((data>>5) + 1);

    // If there is a potentiometer connected to your ADC channel you can use
    // the whole length between 0 - End (0-255) to generate the numbers...
}



void delay(uint16_t time_ms) {
	for(uint16_t i = 0; i < time_ms ; i++) {
		for(uint16_t j = 0; j < 200 ; j++) {
			asm volatile ("NOP");
		}
	}
}

int Start_Beep() {
	//////////////////////////////////////////////////////////////
	//// Plaadi peal on kiri: BUZZER PWM:PB6
	// Datasheet-->PB6 ( PORTB , 6 bit ) Paneme p?sti
	//LDI R16, 0b01000000
	//LDI R18, 0
	// Kirjutame DDRB, et juhtida ainult viiku
	//OUT 0x04, R16 ;DDRB
	//start:
    //EOR R18, R16
	// Kirjutame PORTB peale
	//OUT 0x05, R18 ;PORTB
	// Viivitus algab
	//LDI R17, 0xFF
	//delay_loop:
	//	NOP
	//	NOP
	//	NOP
	//	NOP
	//	NOP
	//	NOP
	//	DEC R17
	//BRNE delay_loop
	//rjmp start
	///////////////////////////////////////////////////////////////
	
	
	// ??????????? ?????? PORTB ?? ?????
	DDRB = 0b01000000; // DDRB |= (1<<PB6)
	
	for(int i = 0; i < 2000; i++) {
		// ??????????? ??? (?????? ???????? ????? 6?? ???? ????? ?????? ???? ???????? (0 ??? 1))
		PORTB ^= 0b01000000;
		// ??? ??????? R17 (255) 
		unsigned char delay_cnt = 0xAA;
		// ???? ????????
		while(delay_cnt){
			// ???????? ? 6 ?????? (????? ??????? ?? ??????? ??), ????????????? 255 ???
			--delay_cnt;	
		}
	}
	return 5;
		
}

int Lose_Beep() {
	DDRB = 0b01000000; // DDRB |= (1<<PB6)
	
	for(int i = 0; i < 300; i++) {
		// ??????????? ??? (?????? ???????? ????? 6?? ???? ????? ?????? ???? ???????? (0 ??? 1))
		PORTB ^= 0b01000000;
		// ??? ??????? R17 (255) 
		unsigned char delay_cnt = 0xFF;
		delay(10);
		// ???? ????????
		while(delay_cnt){
			// ???????? ? 6 ?????? (????? ??????? ?? ??????? ??), ????????????? 255 ???
			--delay_cnt;
		}
	}
	return 5;
}



// ??????? ??? ?????????? ??????? Game ????????? ? ??????
void RandomNumber() {
	
	srand(NewDelayValue());
	for(unsigned int i = 0; i < sizeof(Game)/sizeof(Game[0]); i++) {
		int v = rand() % 2;
		Game[i] = v;
	}
	
}

void PlayDemo() {
	Start_Beep();
	for(; i < 8; i++) {
		if(Game[i] == 1) {
			PORTA = 0x80;
			delay(NewDelayValue());
			PORTA = 0x00;
			delay(NewDelayValue());
			return;
		}
		else if (Game[i] == 0) {
			PORTA = 0x01;
			delay(NewDelayValue());
			PORTA = 0x00;
			delay(NewDelayValue());
			return;
		}
		else {
			PlayDemo();
		}
	}
}


uint8_t isRightButtonPressed(uint8_t PortValue) {
	if(PortValue & 0x08) {
		return 0;
	} else {
		return 1;
	}
}

uint8_t isLeftButtonPressed(uint8_t PortValue) {
	if(PortValue & 0x20) {
		return 0;
	} else {
		return 1;
	}
}

uint8_t isButtonPressed(uint8_t PortValue) {
	return isLeftButtonPressed(PortValue) || isRightButtonPressed(PortValue);
}

enum Button{
	LEFT = 1,
	RIGHT= 0	
};


enum Button waitForPress() {
	/* Kuidas lugeda PINB v??rtust ja teha midagi ainult siis kui bit 2 on k?rge
		if(PINB & 0x04) { (teha midagi) }
	*/
	uint8_t x = PINF;
	// ????? ?????????? ????? ??? ?????? ??????
	//////////////////////////////////////////////////////////////////////
	// ???? --> ?????????
	// ???? --> ????????
	//       AND
	// 1 1 | 1 --> ???? ?????? ?? ??????, ?????? ?? ?????? 1 ( aka ????????? ) 
	// 1 0 | 0 --> ???? ????????? ? ????? ???????, ?????? ???????? ? ?? ?????? ?????? ???? 0 ( aka ???????? )
	// 0 1 | 0 --> ???? ????????? ? ?????? ???????, ?????? ???????? ? ?? ?????? ?????? ???? 0 ( aka ???????? )
	// 0 0 | 0 --> ???? ?? ??? ???? ?????????, ?????? ??? ????????? ( aka ???????? )
	//////////////////////////////////////////////////////////////////////
	// ???? ?? ????? ???????????? ???? ??????, ?????? ?? ??????
	while(!isButtonPressed(x)) {
		x = PINF;
	}
	// Debouncing
	delay(50); 
	while(isButtonPressed(PINF)) {
	}

	if(isRightButtonPressed(x)) {
		return RIGHT;	
	} else {
		return LEFT;
	}
}

int main(void) {
	MCUCR |= 0x80;
	MCUCR |= 0x80;
	DDRA = 0xFF;
	DDRB = 0xFF;
	// 0x20 / 0x08 --> Joystick
	PORTF = 0x28;
	
	ADC_Init();

	RandomNumber();
	PlayDemo();
	
	while(1)
	{
		/*
		if(isRightButtonPressed(PINF)) {
			PORTA = 0x01;
		} else {
			PORTA = 0x00;	
		}
		
		if(isLeftButtonPressed(PINF)) {
			PORTA = 0x80;
		} else {
			PORTA = 0x00;	
		}
		*/
		for(uint8_t index = 0; index < 8; index++) {
			enum Button btn = waitForPress();
			if(btn == Game[index]) {
				PORTA = 0xFF;
				delay(n);
				PORTA = 0x00;
				i++;
				PlayDemo();
			} else if(btn != Game[index]) {
				PORTA = 0xFF;
				Lose_Beep();
				break;
			}
			}
		}
		}

